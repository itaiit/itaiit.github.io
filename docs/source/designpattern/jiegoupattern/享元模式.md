# 享元模式

享元模式的**核心目标是节省内存（避免重复创建结构相同但状态微异的对象）一类相似对象只保留一份模板**。可以理解成如果不使用享元模式就会创建并允许存在大量重复的对象，造成内存的浪费。这是用来识别享元模式的最直观的理解。

享元模式一般结合工厂模式来使用，享元工厂用来存储和管理享元对象的享元池（就是一个内存集合或者叫内存缓存）使用 Map 或者其他结构。当需要享元对象的时候，首先在缓存中读取，如果没有则创建新的对象并把对象放到享元池中；类似于 Map 的 `computeIfAbsent`。

在享元模式中，重点是享元类的设计，在享元类中需要将内部状态和外部状态分开处理。

先来看看享元模式的具体的例子：

```java
// 享元接口
interface CharacterFlyweight {
    void display(int x, int y); // 外部状态：位置
}

// 具体享元类
class ConcreteCharacter implements CharacterFlyweight {
    private char character;
    private String font;
    private int fontSize;
    private String color;

    public ConcreteCharacter(char ch, String font, int fontSize, String color) {
        this.character = ch;
        this.font = font;
        this.fontSize = fontSize;
        this.color = color;
    }

    @Override
    public void display(int x, int y) {
        System.out.printf("显示字符 '%c' 在 (%d, %d)，字体: %s, 大小: %d, 颜色: %s\n",
                character, x, y, font, fontSize, color);
    }
}

// 享元工厂
class CharacterFactory {
    private static Map<String, CharacterFlyweight> flyweights = new HashMap<>();

    public static CharacterFlyweight getCharacter(char ch, String font, int fontSize, String color) {
        String key = ch + "|" + font + "|" + fontSize + "|" + color;
        if (!flyweights.containsKey(key)) {
            flyweights.put(key, new ConcreteCharacter(ch, font, fontSize, color));
            System.out.println("创建新字符享元: " + key);
        }
        return flyweights.get(key);
    }

    public static int getFlyweightCount() {
        return flyweights.size();
    }
}
```

业务方法：

```java
public class FlyweightDemo {
    public static void main(String[] args) {
        // 编辑器中插入多个相同样式的字符
        CharacterFlyweight c1 = CharacterFactory.getCharacter('H', "Arial", 12, "black");
        CharacterFlyweight c2 = CharacterFactory.getCharacter('e', "Arial", 12, "black");
        CharacterFlyweight c3 = CharacterFactory.getCharacter('H', "Arial", 12, "black"); // 复用！

        c1.display(0, 0);
        c2.display(1, 0);
        c3.display(2, 0); // 和 c1 是同一个对象

        System.out.println("享元对象总数: " + CharacterFactory.getFlyweightCount()); // 输出 2
    }
}
```

提问：spring 中的 bean 容器就是使用的设计模式中的享元模式吗？

通过享元模式的核心目标是节省内存，优化掉重复创建相同对象的不雅之处，而不是不能创建重复对象。而 spring 容器本质是缓存，只是用来保存 bean 对象的地方，而不是为了防止创建重复对象的地方。

Spring 的单例是“一个类只创建一次”，而享元是“一类相似对象只保留一份模板，通过参数区分”。

如果享元工厂的内部状态需要保存不同类型的对象，可以为每种对象类型都创建一个单例的享元工厂；或者使用泛型，来创建一个通用的享元工厂。