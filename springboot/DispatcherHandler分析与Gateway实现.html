

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../">
<head>
  <meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>DispatcherHandler 分析与 Gateway 实现 &mdash; ITAIIT&#39;s Notebook</title>
      <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=b86133f3" />
      <link rel="stylesheet" type="text/css" href="../_static/css/theme.css?v=e59714d7" />
      <link rel="stylesheet" type="text/css" href="../_static/custom.css?v=706144a1" />

  
      <script src="../_static/jquery.js?v=5d32c60e"></script>
      <script src="../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../_static/documentation_options.js?v=2709fde1"></script>
      <script src="../_static/doctools.js?v=9bcbadda"></script>
      <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="日志 Logger-JCL, Slf4j" href="%E6%97%A5%E5%BF%97Logger.html" />
    <link rel="prev" title="Web 服务器的启动流程分析" href="Web%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../index.html" class="icon icon-home">
            ITAIIT's Notebook
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul class="current">
<li class="toctree-l1 current"><a class="reference internal" href="index.html">SpringBoot</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="%E5%B7%A5%E5%85%B7%E7%B1%BB-PropertyMapper.html">介绍工具类 PropertyMapper</a></li>
<li class="toctree-l2"><a class="reference internal" href="embed%20tomcat%E7%9A%84%E5%8A%A0%E8%BD%BD%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90.html">分析 SpringBoot 中的 embed tomcat 加载流程</a></li>
<li class="toctree-l2"><a class="reference internal" href="%E5%AF%B9%E4%BA%8EAop%E7%9A%84%E8%A7%A3%E6%9E%90%E5%8E%9F%E7%90%86%E5%92%8C%40Transactional%E6%B3%A8%E8%A7%A3%E8%A7%A3%E6%9E%90%E5%8E%9F%E7%90%86.html">分析一下 SpringBoot 的 Aop 的解析和 &#64;Transactional 注解解析原理</a></li>
<li class="toctree-l2"><a class="reference internal" href="Web%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90.html">Web 服务器的启动流程分析</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">DispatcherHandler 分析与 Gateway 实现</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#dispatcherhandler">DispatcherHandler处理请求</a></li>
<li class="toctree-l3"><a class="reference internal" href="#ping">从ping请求看方法调用</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#handlermappinghandler">HandlerMapping匹配获得Handler</a></li>
<li class="toctree-l4"><a class="reference internal" href="#handleradapter">HandlerAdapter处理执行请求</a></li>
<li class="toctree-l4"><a class="reference internal" href="#handlerresulthandler">HandlerResultHandler处理请求结果</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#gateway">Gateway中拓展实现</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id1">总结</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="%E6%97%A5%E5%BF%97Logger.html">日志 Logger-JCL, Slf4j</a></li>
</ul>
</li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">ITAIIT's Notebook</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="index.html">SpringBoot</a></li>
      <li class="breadcrumb-item active">DispatcherHandler 分析与 Gateway 实现</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../_sources/springboot/DispatcherHandler分析与Gateway实现.md.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="dispatcherhandler-gateway">
<h1>DispatcherHandler 分析与 Gateway 实现<a class="headerlink" href="#dispatcherhandler-gateway" title="Link to this heading"></a></h1>
<p>经过前面<a class="reference internal" href="Web%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90.html"><span class="std std-doc">对于Spring Boot的Web请求处理流程分析</span></a>，我们知道当请求进入服务器之后会被netty的handler处理然后转入spring boot的handler处理逻辑。在reactive类型的web容器场景下，进过spring boot的handler经过了层层的封装，但最核心的则是名为webHandler的实例：DispatcherHandler。下面我们来分析一下该类的结构以及可以进行的拓展。</p>
<section id="dispatcherhandler">
<h2>DispatcherHandler处理请求<a class="headerlink" href="#dispatcherhandler" title="Link to this heading"></a></h2>
<p>我们还是先来看DispatcherHandler是如何一步一步构造出来的，流程图如下：</p>
<p><img alt="img" src="../_images/httphandler-1-1024x421.png" /></p>
<p>DispatcherHandler是在图中的步骤3中从容器中获取名为“webHandler”的bean得到的，最终返回的则是层层的封装的到的HttpWebHandlerAdapter。</p>
<p>DispatcherHandler实现了WebHandler接口，重写了<code class="docutils literal notranslate"><span class="pre">handle(ServerWebExchange</span> <span class="pre">exchange)</span></code>方法。当处理请求的时候，执行流程则与图中的构造过程相反，依次执行handler方法，最终执行到DispatcherHandler.handler方法。</p>
<p>DispatcherHandler有三个自动注入的属性：</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>List<HandlerMapping> handlerMappings;</p></th>
<th class="head"><p>根据请求信息，判断出使用哪个handler来处理</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>List<HandlerAdapter> handlerAdapters;</p></td>
<td><p>使用handlerAdapter来执行handler，返回执行结果</p></td>
</tr>
<tr class="row-odd"><td><p>List<HandlerResultHandler> resultHandlers;</p></td>
<td><p>对执行结果进行处理，例如json序列化操作</p></td>
</tr>
</tbody>
</table>
<p>来看一下具体的处理流程：</p>
<p><img alt="img" src="../_images/dispatcherhandler-2.png" /></p>
<p>在处理请求的时候，会遍历所有的<code class="docutils literal notranslate"><span class="pre">HandlerMapping</span></code>，根据当前请求的信息通过<code class="docutils literal notranslate"><span class="pre">getHandler</span></code>方法获得到与当前请求匹配的handler，然后交给对应的<code class="docutils literal notranslate"><span class="pre">HandlerAdapter</span></code>来执行handler。</p>
<p><code class="docutils literal notranslate"><span class="pre">HandlerAdapter</span></code>的存在是为了让handler的执行逻辑和<code class="docutils literal notranslate"><span class="pre">DispatcherHandler</span></code>解耦，因为执行handler的时候可能不是简单的去调用handler的handle方法，还需要额外的逻辑，因此将handler的具体执行交给<code class="docutils literal notranslate"><span class="pre">HandlerAdapter</span></code>。</p>
<p>spring中也内置了<code class="docutils literal notranslate"><span class="pre">HandlerAdapter</span></code>，通过<code class="docutils literal notranslate"><span class="pre">supports</span></code>方法判断来处理不同功能的<code class="docutils literal notranslate"><span class="pre">HandlerMapping</span></code>。</p>
<p><img alt="img" src="../_images/image-1-1024x109.png" /></p>
<p>根据上面的理解，我们可以知道在处理请求的过程中HandlerMapping、HandlerAdapter和HandlerResultHandler是很重要的组件。我们通过对于一个请求的跟踪来看一下这三着是如何协作的。</p>
</section>
<section id="ping">
<h2>从ping请求看方法调用<a class="headerlink" href="#ping" title="Link to this heading"></a></h2>
<p>我们通过postman发送请求：<em>GET localhost/ping</em>，然后在DispatcherHandler类中打断点来看一下执行流程。</p>
<section id="handlermappinghandler">
<h3>HandlerMapping匹配获得Handler<a class="headerlink" href="#handlermappinghandler" title="Link to this heading"></a></h3>
<p><img alt="img" src="../_images/Snipaste_2025-05-14_14-37-48-1024x233.png" /></p>
<p>当程序执行到断点之后，查看handlerMappings的集合里面有其他元素，我们在详细看一下这七个实例的详细的信息：</p>
<p><img alt="img" src="../_images/Snipaste_2025-05-14_14-39-41.png" /></p>
<p>在上图中可以看到集合中每个HandlerMapping的顺序和在容器中的bean名称，顺序值越小优先级越高，在遍历的时候也是按照优先级由小到大的顺序依次遍历。</p>
<p>这里通过调试方式找到当遍历到RequestMappingHandlerMapping的时候会获取到我的controller方法</p>
<p><img alt="img" src="../_images/Snipaste_2025-05-14_14-51-01-1024x157.png" /></p>
</section>
<section id="handleradapter">
<h3>HandlerAdapter处理执行请求<a class="headerlink" href="#handleradapter" title="Link to this heading"></a></h3>
<p>通过遍历handlerMapping找到了与当前请求匹配的handler，接下来会将我们获取到的handler交给handlerAdapter来处理，我们看到这里有四个HandlerAdapter的实现：</p>
<p><img alt="img" src="../_images/Snipaste_2025-05-14_15-27-59-1024x186.png" /></p>
<p>我这里的handler是HandlerMethod对象，我们查看HandlerAdapter的supports方法看是否支持：</p>
<p><img alt="img" src="../_images/Snipaste_2025-05-14_14-57-37-1024x277.png" /></p>
<p>可以看到匹配到的是RequestMappingHandlerAdapter。接下来就是执行它的handle方法进行处理并返回执行结果。</p>
</section>
<section id="handlerresulthandler">
<h3>HandlerResultHandler处理请求结果<a class="headerlink" href="#handlerresulthandler" title="Link to this heading"></a></h3>
<p>当我们通过HandlerAdapter执行完controller的逻辑之后，我们会返回一个结果，接下来会把结果交给HandlerResultHandler来处理。我们来看系统预置的实现：</p>
<p><img alt="img" src="../_images/Snipaste_2025-05-14_14-59-42-1024x232.png" /></p>
<p>通过这四个实现类的名称，大致也能明白了每个实现处理哪种类型的返回。我们就来看熟悉的<code class="docutils literal notranslate"><span class="pre">ResponseBodyResultHandler</span></code>吧，我们经常使用<code class="docutils literal notranslate"><span class="pre">&#64;RestController</span></code>修饰类或者<code class="docutils literal notranslate"><span class="pre">&#64;ResponseBody</span></code>来修饰类或者方法，这样我们就会接收到json格式的响应。来看一下<code class="docutils literal notranslate"><span class="pre">supports</span></code>方法：</p>
<p><img alt="img" src="../_images/Snipaste_2025-05-14_15-08-25-1024x272.png" /></p>
<p><code class="docutils literal notranslate"><span class="pre">ResponseBodyResultHandler</span></code>也确实是这么进行判断的，满足<code class="docutils literal notranslate"><span class="pre">supports</span></code>方法的条件，那么就会使用<code class="docutils literal notranslate"><span class="pre">ResponseBodyResultHandler</span></code>来处理响应结果。</p>
</section>
</section>
<section id="gateway">
<h2>Gateway中拓展实现<a class="headerlink" href="#gateway" title="Link to this heading"></a></h2>
<p>我的项目因为引入了spring-cloud-starter-gateway，我们仔细观察一下上面调试的时候的HandlerMapping的集合，可以看到有一个名为<code class="docutils literal notranslate"><span class="pre">RoutePredicateHandlerMapping</span></code>的实现类，这个实现类就是Gateway中的类，他对应的handler是<code class="docutils literal notranslate"><span class="pre">FilteringWebHandler</span></code>，也就是说如果当前请求匹配到这个HandlerMapping的时候，返回的handler就是<code class="docutils literal notranslate"><span class="pre">FilteringWebHandler</span></code>。</p>
<p>那么使用哪个HandlerAdapter来执行呢，还是在上面我们调试的时候看到的那四个HandlerAdapter中，只需要查看每个的supports方法或者进行断点调试即可。</p>
<p>最终我们定位到是优先级最低的那个，即<code class="docutils literal notranslate"><span class="pre">SimpleHandlerAdapter</span></code>。看一下这个类的<code class="docutils literal notranslate"><span class="pre">supports</span></code>方法和handler方法的逻辑：</p>
<div class="highlight-java notranslate"><div class="highlight"><pre><span></span><span class="kd">public</span><span class="w"> </span><span class="kd">class</span> <span class="nc">SimpleHandlerAdapter</span><span class="w"> </span><span class="kd">implements</span><span class="w"> </span><span class="n">HandlerAdapter</span><span class="w"> </span><span class="p">{</span>

<span class="w">	</span><span class="nd">@Override</span>
<span class="w">	</span><span class="kd">public</span><span class="w"> </span><span class="kt">boolean</span><span class="w"> </span><span class="nf">supports</span><span class="p">(</span><span class="n">Object</span><span class="w"> </span><span class="n">handler</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">		</span><span class="k">return</span><span class="w"> </span><span class="n">WebHandler</span><span class="p">.</span><span class="na">class</span><span class="p">.</span><span class="na">isAssignableFrom</span><span class="p">(</span><span class="n">handler</span><span class="p">.</span><span class="na">getClass</span><span class="p">());</span>
<span class="w">	</span><span class="p">}</span>

<span class="w">	</span><span class="nd">@Override</span>
<span class="w">	</span><span class="kd">public</span><span class="w"> </span><span class="n">Mono</span><span class="o">&lt;</span><span class="n">HandlerResult</span><span class="o">&gt;</span><span class="w"> </span><span class="nf">handle</span><span class="p">(</span><span class="n">ServerWebExchange</span><span class="w"> </span><span class="n">exchange</span><span class="p">,</span><span class="w"> </span><span class="n">Object</span><span class="w"> </span><span class="n">handler</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">		</span><span class="n">WebHandler</span><span class="w"> </span><span class="n">webHandler</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">WebHandler</span><span class="p">)</span><span class="w"> </span><span class="n">handler</span><span class="p">;</span>
<span class="w">		</span><span class="n">Mono</span><span class="o">&lt;</span><span class="n">Void</span><span class="o">&gt;</span><span class="w"> </span><span class="n">mono</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">webHandler</span><span class="p">.</span><span class="na">handle</span><span class="p">(</span><span class="n">exchange</span><span class="p">);</span>
<span class="w">		</span><span class="k">return</span><span class="w"> </span><span class="n">mono</span><span class="p">.</span><span class="na">then</span><span class="p">(</span><span class="n">Mono</span><span class="p">.</span><span class="na">empty</span><span class="p">());</span>
<span class="w">	</span><span class="p">}</span>

<span class="p">}</span>
</pre></div>
</div>
<p>上面是这个类的全部内容，看上去就很简单了，<strong>能够匹配到所有WebHandler的子类并且直接执行webHandler.handle方法</strong>，并没有多余的逻辑。</p>
<p>Gateway的更详细的实现逻辑就不再这里赘述了。可以参考：<a class="reference external" href="https://itaiit.top/2025/05/12/gateway%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E7%8E%B0/">gateway的工作原理与实现</a>。</p>
</section>
<section id="id1">
<h2>总结<a class="headerlink" href="#id1" title="Link to this heading"></a></h2>
<p>DispatcherHandler是Spring WebFlux用来处理请求的核心类，封装了HandlerMapping、HandlerAdapter和HandelResultHandler三个组件。HandlerMapping负责找出与请求匹配的handler，可能有1-n个；HandlerAdapter只会取出第一个来进行处理，然后将执行的结果提供给HandelResultHandler来进行处理。</p>
<p><img alt="img" src="../_images/Snipaste_2025-05-14_16-06-08-1024x83.png" /></p>
<p>在上面的执行流程中，这三个组件都是通过自动注入的方式进行的实例化，我们都可以进行拓展。在Gateway中就是拓展的HandlerMapping来进行的实现。</p>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="Web%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90.html" class="btn btn-neutral float-left" title="Web 服务器的启动流程分析" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="%E6%97%A5%E5%BF%97Logger.html" class="btn btn-neutral float-right" title="日志 Logger-JCL, Slf4j" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2025, itaiit.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>