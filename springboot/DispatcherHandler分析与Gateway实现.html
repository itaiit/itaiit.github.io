<!DOCTYPE html>

<html lang="en" data-content_root="../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>DispatcherHandler分析与Gateway实现 &#8212; Notebook 0.1 documentation</title>
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=8e8a900e" />
    <link rel="stylesheet" type="text/css" href="../_static/traditional.css?v=f6356284" />
    <link rel="stylesheet" type="text/css" href="../_static/custom.css?v=4eb2f63a" />
    <script src="../_static/documentation_options.js?v=2709fde1"></script>
    <script src="../_static/doctools.js?v=9bcbadda"></script>
    <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="prev" title="Web服务器的启动流程分析" href="Web%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="Related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="Web%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90.html" title="Web服务器的启动流程分析"
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="../index.html">Notebook 0.1 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="index.html" accesskey="U">springboot</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">DispatcherHandler分析与Gateway实现</a></li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <section id="dispatcherhandlergateway">
<h1>DispatcherHandler分析与Gateway实现<a class="headerlink" href="#dispatcherhandlergateway" title="Link to this heading">¶</a></h1>
<p>经过前面[对于Spring Boot的Web请求处理流程分析]({{&lt;ref “Spring Boot之Web服务器的启动流程分析.md”&gt;}})，我们知道当请求进入服务器之后会被netty的handler处理然后转入spring boot的handler处理逻辑。在reactive类型的web容器场景下，进过spring boot的handler经过了层层的封装，但最核心的则是名为webHandler的实例：DispatcherHandler。下面我们来分析一下该类的结构以及可以进行的拓展。</p>
<section id="dispatcherhandler">
<h2>DispatcherHandler处理请求<a class="headerlink" href="#dispatcherhandler" title="Link to this heading">¶</a></h2>
<p>我们还是先来看DispatcherHandler是如何一步一步构造出来的，流程图如下：</p>
<p><img alt="img" src="../_images/httphandler-1-1024x421.png" /></p>
<p>DispatcherHandler是在图中的步骤3中从容器中获取名为“webHandler”的bean得到的，最终返回的则是层层的封装的到的HttpWebHandlerAdapter。</p>
<p>DispatcherHandler实现了WebHandler接口，重写了<code class="docutils literal notranslate"><span class="pre">handle(ServerWebExchange</span> <span class="pre">exchange)</span></code>方法。当处理请求的时候，执行流程则与图中的构造过程相反，依次执行handler方法，最终执行到DispatcherHandler.handler方法。</p>
<p>DispatcherHandler有三个自动注入的属性：</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>List<HandlerMapping> handlerMappings;</p></th>
<th class="head"><p>根据请求信息，判断出使用哪个handler来处理</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>List<HandlerAdapter> handlerAdapters;</p></td>
<td><p>使用handlerAdapter来执行handler，返回执行结果</p></td>
</tr>
<tr class="row-odd"><td><p>List<HandlerResultHandler> resultHandlers;</p></td>
<td><p>对执行结果进行处理，例如json序列化操作</p></td>
</tr>
</tbody>
</table>
<p>来看一下具体的处理流程：</p>
<p><img alt="img" src="../_images/dispatcherhandler-2.png" /></p>
<p>在处理请求的时候，会遍历所有的<code class="docutils literal notranslate"><span class="pre">HandlerMapping</span></code>，根据当前请求的信息通过<code class="docutils literal notranslate"><span class="pre">getHandler</span></code>方法获得到与当前请求匹配的handler，然后交给对应的<code class="docutils literal notranslate"><span class="pre">HandlerAdapter</span></code>来执行handler。</p>
<p><code class="docutils literal notranslate"><span class="pre">HandlerAdapter</span></code>的存在是为了让handler的执行逻辑和<code class="docutils literal notranslate"><span class="pre">DispatcherHandler</span></code>解耦，因为执行handler的时候可能不是简单的去调用handler的handle方法，还需要额外的逻辑，因此将handler的具体执行交给<code class="docutils literal notranslate"><span class="pre">HandlerAdapter</span></code>。</p>
<p>spring中也内置了<code class="docutils literal notranslate"><span class="pre">HandlerAdapter</span></code>，通过<code class="docutils literal notranslate"><span class="pre">supports</span></code>方法判断来处理不同功能的<code class="docutils literal notranslate"><span class="pre">HandlerMapping</span></code>。</p>
<p><img alt="img" src="../_images/image-1-1024x109.png" /></p>
<p>根据上面的理解，我们可以知道在处理请求的过程中HandlerMapping、HandlerAdapter和HandlerResultHandler是很重要的组件。我们通过对于一个请求的跟踪来看一下这三着是如何协作的。</p>
</section>
<section id="ping">
<h2>从ping请求看方法调用<a class="headerlink" href="#ping" title="Link to this heading">¶</a></h2>
<p>我们通过postman发送请求：<em>GET localhost/ping</em>，然后在DispatcherHandler类中打断点来看一下执行流程。</p>
<section id="handlermappinghandler">
<h3>HandlerMapping匹配获得Handler<a class="headerlink" href="#handlermappinghandler" title="Link to this heading">¶</a></h3>
<p><img alt="img" src="../_images/Snipaste_2025-05-14_14-37-48-1024x233.png" /></p>
<p>当程序执行到断点之后，查看handlerMappings的集合里面有其他元素，我们在详细看一下这七个实例的详细的信息：</p>
<p><img alt="img" src="../_images/Snipaste_2025-05-14_14-39-41.png" /></p>
<p>在上图中可以看到集合中每个HandlerMapping的顺序和在容器中的bean名称，顺序值越小优先级越高，在遍历的时候也是按照优先级由小到大的顺序依次遍历。</p>
<p>这里通过调试方式找到当遍历到RequestMappingHandlerMapping的时候会获取到我的controller方法</p>
<p><img alt="img" src="../_images/Snipaste_2025-05-14_14-51-01-1024x157.png" /></p>
</section>
<section id="handleradapter">
<h3>HandlerAdapter处理执行请求<a class="headerlink" href="#handleradapter" title="Link to this heading">¶</a></h3>
<p>通过遍历handlerMapping找到了与当前请求匹配的handler，接下来会将我们获取到的handler交给handlerAdapter来处理，我们看到这里有四个HandlerAdapter的实现：</p>
<p><img alt="img" src="../_images/Snipaste_2025-05-14_15-27-59-1024x186.png" /></p>
<p>我这里的handler是HandlerMethod对象，我们查看HandlerAdapter的supports方法看是否支持：</p>
<p><img alt="img" src="../_images/Snipaste_2025-05-14_14-57-37-1024x277.png" /></p>
<p>可以看到匹配到的是RequestMappingHandlerAdapter。接下来就是执行它的handle方法进行处理并返回执行结果。</p>
</section>
<section id="handlerresulthandler">
<h3>HandlerResultHandler处理请求结果<a class="headerlink" href="#handlerresulthandler" title="Link to this heading">¶</a></h3>
<p>当我们通过HandlerAdapter执行完controller的逻辑之后，我们会返回一个结果，接下来会把结果交给HandlerResultHandler来处理。我们来看系统预置的实现：</p>
<p><img alt="img" src="../_images/Snipaste_2025-05-14_14-59-42-1024x232.png" /></p>
<p>通过这四个实现类的名称，大致也能明白了每个实现处理哪种类型的返回。我们就来看熟悉的<code class="docutils literal notranslate"><span class="pre">ResponseBodyResultHandler</span></code>吧，我们经常使用<code class="docutils literal notranslate"><span class="pre">&#64;RestController</span></code>修饰类或者<code class="docutils literal notranslate"><span class="pre">&#64;ResponseBody</span></code>来修饰类或者方法，这样我们就会接收到json格式的响应。来看一下<code class="docutils literal notranslate"><span class="pre">supports</span></code>方法：</p>
<p><img alt="img" src="../_images/Snipaste_2025-05-14_15-08-25-1024x272.png" /></p>
<p><code class="docutils literal notranslate"><span class="pre">ResponseBodyResultHandler</span></code>也确实是这么进行判断的，满足<code class="docutils literal notranslate"><span class="pre">supports</span></code>方法的条件，那么就会使用<code class="docutils literal notranslate"><span class="pre">ResponseBodyResultHandler</span></code>来处理响应结果。</p>
</section>
</section>
<section id="gateway">
<h2>Gateway中拓展实现<a class="headerlink" href="#gateway" title="Link to this heading">¶</a></h2>
<p>我的项目因为引入了spring-cloud-starter-gateway，我们仔细观察一下上面调试的时候的HandlerMapping的集合，可以看到有一个名为<code class="docutils literal notranslate"><span class="pre">RoutePredicateHandlerMapping</span></code>的实现类，这个实现类就是Gateway中的类，他对应的handler是<code class="docutils literal notranslate"><span class="pre">FilteringWebHandler</span></code>，也就是说如果当前请求匹配到这个HandlerMapping的时候，返回的handler就是<code class="docutils literal notranslate"><span class="pre">FilteringWebHandler</span></code>。</p>
<p>那么使用哪个HandlerAdapter来执行呢，还是在上面我们调试的时候看到的那四个HandlerAdapter中，只需要查看每个的supports方法或者进行断点调试即可。</p>
<p>最终我们定位到是优先级最低的那个，即<code class="docutils literal notranslate"><span class="pre">SimpleHandlerAdapter</span></code>。看一下这个类的<code class="docutils literal notranslate"><span class="pre">supports</span></code>方法和handler方法的逻辑：</p>
<div class="highlight-java notranslate"><div class="highlight"><pre><span></span><span class="kd">public</span><span class="w"> </span><span class="kd">class</span> <span class="nc">SimpleHandlerAdapter</span><span class="w"> </span><span class="kd">implements</span><span class="w"> </span><span class="n">HandlerAdapter</span><span class="w"> </span><span class="p">{</span>

<span class="w">	</span><span class="nd">@Override</span>
<span class="w">	</span><span class="kd">public</span><span class="w"> </span><span class="kt">boolean</span><span class="w"> </span><span class="nf">supports</span><span class="p">(</span><span class="n">Object</span><span class="w"> </span><span class="n">handler</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">		</span><span class="k">return</span><span class="w"> </span><span class="n">WebHandler</span><span class="p">.</span><span class="na">class</span><span class="p">.</span><span class="na">isAssignableFrom</span><span class="p">(</span><span class="n">handler</span><span class="p">.</span><span class="na">getClass</span><span class="p">());</span>
<span class="w">	</span><span class="p">}</span>

<span class="w">	</span><span class="nd">@Override</span>
<span class="w">	</span><span class="kd">public</span><span class="w"> </span><span class="n">Mono</span><span class="o">&lt;</span><span class="n">HandlerResult</span><span class="o">&gt;</span><span class="w"> </span><span class="nf">handle</span><span class="p">(</span><span class="n">ServerWebExchange</span><span class="w"> </span><span class="n">exchange</span><span class="p">,</span><span class="w"> </span><span class="n">Object</span><span class="w"> </span><span class="n">handler</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">		</span><span class="n">WebHandler</span><span class="w"> </span><span class="n">webHandler</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">WebHandler</span><span class="p">)</span><span class="w"> </span><span class="n">handler</span><span class="p">;</span>
<span class="w">		</span><span class="n">Mono</span><span class="o">&lt;</span><span class="n">Void</span><span class="o">&gt;</span><span class="w"> </span><span class="n">mono</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">webHandler</span><span class="p">.</span><span class="na">handle</span><span class="p">(</span><span class="n">exchange</span><span class="p">);</span>
<span class="w">		</span><span class="k">return</span><span class="w"> </span><span class="n">mono</span><span class="p">.</span><span class="na">then</span><span class="p">(</span><span class="n">Mono</span><span class="p">.</span><span class="na">empty</span><span class="p">());</span>
<span class="w">	</span><span class="p">}</span>

<span class="p">}</span>
</pre></div>
</div>
<p>上面是这个类的全部内容，看上去就很简单了，<strong>能够匹配到所有WebHandler的子类并且直接执行webHandler.handle方法</strong>，并没有多余的逻辑。</p>
<p>Gateway的更详细的实现逻辑就不再这里赘述了。可以参考：<a class="reference external" href="https://itaiit.top/2025/05/12/gateway%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E7%8E%B0/">gateway的工作原理与实现</a>。</p>
</section>
<section id="id1">
<h2>总结<a class="headerlink" href="#id1" title="Link to this heading">¶</a></h2>
<p>DispatcherHandler是Spring WebFlux用来处理请求的核心类，封装了HandlerMapping、HandlerAdapter和HandelResultHandler三个组件。HandlerMapping负责找出与请求匹配的handler，可能有1-n个；HandlerAdapter只会取出第一个来进行处理，然后将执行的结果提供给HandelResultHandler来进行处理。</p>
<p><img alt="img" src="../_images/Snipaste_2025-05-14_16-06-08-1024x83.png" /></p>
<p>在上面的执行流程中，这三个组件都是通过自动注入的方式进行的实例化，我们都可以进行拓展。在Gateway中就是拓展的HandlerMapping来进行的实现。</p>
</section>
</section>


            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="Main">
        <div class="sphinxsidebarwrapper">
  <div>
    <h3><a href="../index.html">Table of Contents</a></h3>
    <ul>
<li><a class="reference internal" href="#">DispatcherHandler分析与Gateway实现</a><ul>
<li><a class="reference internal" href="#dispatcherhandler">DispatcherHandler处理请求</a></li>
<li><a class="reference internal" href="#ping">从ping请求看方法调用</a><ul>
<li><a class="reference internal" href="#handlermappinghandler">HandlerMapping匹配获得Handler</a></li>
<li><a class="reference internal" href="#handleradapter">HandlerAdapter处理执行请求</a></li>
<li><a class="reference internal" href="#handlerresulthandler">HandlerResultHandler处理请求结果</a></li>
</ul>
</li>
<li><a class="reference internal" href="#gateway">Gateway中拓展实现</a></li>
<li><a class="reference internal" href="#id1">总结</a></li>
</ul>
</li>
</ul>

  </div>
  <div>
    <h4>Previous topic</h4>
    <p class="topless"><a href="Web%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90.html"
                          title="previous chapter">Web服务器的启动流程分析</a></p>
  </div>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../_sources/springboot/DispatcherHandler分析与Gateway实现.md.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<search id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</search>
<script>document.getElementById('searchbox').style.display = "block"</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="Related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="Web%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90.html" title="Web服务器的启动流程分析"
             >previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="../index.html">Notebook 0.1 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="index.html" >springboot</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">DispatcherHandler分析与Gateway实现</a></li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
    &#169; Copyright 2025, itaiit.
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 8.2.3.
    </div>
  </body>
</html>